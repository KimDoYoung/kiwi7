# 설계

- kdemon :  table rule에 따라서 알아서 동작한다.
- OpentimeChecker : 오늘, 시각에 따라서 현재 어떤 시장을 선택할 지 알려준다. KRX,NXT,None 

## kdemon

```text
데몬 성격의 모듈을 붙일 수 있을까? 예를 들어 kdemon 이라고 부르자. 사용자가 api를 호출하면 ㅏtable에 저장을 하고 kdemon에 command `refresh'를 보내면 table에 저장된 명령어들을 다시 loading, `stop`을 보내면 kdemon stop,  start... 이렇게 kdemon.에 명령얼 보내는 식으로 하면 좋을 듯. kdemon은 등록된 명령에 따라서 즉 a종목이 100원이상이면 10주를 매도해라 이런 것을 자동으로 하는 것이지. 물론 주어진 시간마다 현재가를 가져와서 해당하는 명령이 있는지 체크하고
```

```sql
-- kdemon_rules: 자동매매 룰
CREATE TABLE IF NOT EXISTS kdemon_rules (
  id                INTEGER PRIMARY KEY AUTOINCREMENT,
  name              TEXT NOT NULL,
  symbol            TEXT NOT NULL,                -- 종목코드 (예: 005930)
  condition_op      TEXT NOT NULL,                -- 'gte' | 'lte' | 'cross_up' | 'cross_down'
  threshold         REAL NOT NULL,                -- 기준값 (예: 100.0)
  action            TEXT NOT NULL,                -- 'buy' | 'sell'
  qty               INTEGER NOT NULL,             -- 수량
  status            TEXT NOT NULL DEFAULT 'active', -- 'active' | 'paused' | 'done'
  cooldown_sec      INTEGER NOT NULL DEFAULT 60,  -- 재트리거 쿨다운
  valid_from        TEXT,                         -- 'YYYYMMDDHHMMSS' (옵션)
  valid_to          TEXT,                         -- 'YYYYMMDDHHMMSS' (옵션)
  last_price        REAL,                         -- 직전 가격(크로스 판정용)
  last_triggered_at TEXT,                         -- 마지막 실행 시각 'YYYYMMDDHHMMSS'
  notes             TEXT
);

-- kdemon_commands: 제어 명령 큐
CREATE TABLE IF NOT EXISTS kdemon_commands (
  id           INTEGER PRIMARY KEY AUTOINCREMENT,
  cmd          TEXT NOT NULL,            -- 'start' | 'stop' | 'refresh'
  args_json    TEXT,                     -- 옵션 인자(JSON)
  created_at   TEXT NOT NULL,            -- 'YYYYMMDDHHMMSS'
  processed_at TEXT                      -- 처리 완료 시각
);

-- kdemon_state: 데몬 상태(싱글톤 1row)
CREATE TABLE IF NOT EXISTS kdemon_state (
  id             INTEGER PRIMARY KEY CHECK (id = 1),
  status         TEXT NOT NULL,  -- 'stopped' | 'running'
  updated_at     TEXT NOT NULL
);

INSERT OR IGNORE INTO kdemon_state (id, status, updated_at)
VALUES (1, 'stopped', strftime('%Y%m%d%H%M%S','now','localtime'));

```
```python
# backend/domains/kdemon/kdemon.py
from __future__ import annotations
import asyncio
import json
import sqlite3
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List, Optional

from backend.core.logger import get_logger
from backend.domains.kiwoom.kiwoom_api import KiwoomStockApi  # 기존 구현 사용
from backend.core.config import config

logger = get_logger(__name__)

def now_ymdhms() -> str:
    return datetime.now().strftime("%Y%m%d%H%M%S")

@dataclass
class Rule:
    id: int
    name: str
    symbol: str
    condition_op: str
    threshold: float
    action: str
    qty: int
    status: str
    cooldown_sec: int
    valid_from: Optional[str]
    valid_to: Optional[str]
    last_price: Optional[float]
    last_triggered_at: Optional[str]

class KDemon:
    """주기적으로 가격을 조회하고 룰을 평가해 주문을 실행하는 데몬."""
    _instance: "KDemon|None" = None

    def __init__(self, db_path: str, poll_interval_sec: int = 5, dry_run: bool = True):
        self.db_path = db_path
        self.poll_interval_sec = poll_interval_sec
        self.dry_run = dry_run  # True면 실제 주문 대신 로그만
        self._task: Optional[asyncio.Task] = None
        self._stop_event = asyncio.Event()
        self._refresh_event = asyncio.Event()
        self._rules: List[Rule] = []
        self._conn = sqlite3.connect(self.db_path, check_same_thread=False)
        self._conn.row_factory = sqlite3.Row
        self._api = KiwoomStockApi()

    # ---------- singleton ----------
    @classmethod
    def get(cls, db_path: str, poll_interval_sec: int = 5, dry_run: bool = True) -> "KDemon":
        if cls._instance is None:
            cls._instance = KDemon(db_path, poll_interval_sec, dry_run)
        return cls._instance

    # ---------- DB helpers ----------
    def _fetch_rules(self) -> List[Rule]:
        cur = self._conn.cursor()
        cur.execute("""
            SELECT * FROM kdemon_rules WHERE status='active'
        """)
        rules = []
        for r in cur.fetchall():
            rules.append(Rule(
                id=r["id"], name=r["name"], symbol=r["symbol"],
                condition_op=r["condition_op"], threshold=float(r["threshold"]),
                action=r["action"], qty=int(r["qty"]), status=r["status"],
                cooldown_sec=int(r["cooldown_sec"]),
                valid_from=r["valid_from"], valid_to=r["valid_to"],
                last_price=r["last_price"] if r["last_price"] is not None else None,
                last_triggered_at=r["last_triggered_at"]
            ))
        return rules

    def _update_rule_after_tick(self, rule: Rule, price: float, triggered: bool):
        cur = self._conn.cursor()
        if triggered:
            cur.execute("""
                UPDATE kdemon_rules
                   SET last_price=?, last_triggered_at=?
                 WHERE id=?
            """, (price, now_ymdhms(), rule.id))
        else:
            cur.execute("""
                UPDATE kdemon_rules
                   SET last_price=?
                 WHERE id=?
            """, (price, rule.id))
        self._conn.commit()

    def _set_state(self, status: str):
        cur = self._conn.cursor()
        cur.execute("""
            UPDATE kdemon_state
               SET status=?, updated_at=?
             WHERE id=1
        """, (status, now_ymdhms()))
        self._conn.commit()

    # ---------- Kiwoom helpers ----------
    async def _ensure_token(self):
        await self._api.refresh_token()

    async def _get_current_price(self, symbol: str) -> Optional[float]:
        """종목 현재가 조회. 실제 API id는 프로젝트에 맞춰 교체."""
        # 예시: 시세조회 API 아이디/페이로드는 환경에 맞게 조정
        req = {
            "api_id": "ka11001",         # <-- 실제 현재가/호가 API로 교체
            "cont_yn": "N",
            "next_key": "",
            "payload": {"stk_cd": symbol}
        }
        try:
            resp = await self._api.send_request(req)  # KiwoomStockApi는 dataclass 사용 중이면 맞춰 wrapping
            # 응답 구조에 맞게 파싱 (예: resp["output"]["현재가"])
            price = float(resp["output"]["현재가"])
            return price
        except Exception as e:
            logger.error(f"[kdemon] 현재가 조회 실패 {symbol}: {e}")
            return None

    async def _place_order(self, rule: Rule, price: float):
        """주문 실행. 실제 API/필드명은 환경에 맞게 교체."""
        if self.dry_run:
            logger.info(f"[kdemon] (DRY-RUN) {rule.action.upper()} {rule.qty} @ {price} / {rule.symbol} (rule:{rule.id})")
            return

        api_id = "ka20001"  # 예: 현금 매수/매도 API ID로 교체
        side = "01" if rule.action == "buy" else "02"  # 예) 01=매수, 02=매도(실제 문서 확인)
        req = {
            "api_id": api_id,
            "cont_yn": "N",
            "next_key": "",
            "payload": {
                "stk_cd": rule.symbol,
                "ord_qty": rule.qty,
                "ord_prc": price,      # 지정가/시장가 정책에 맞게 필드 조정
                "ord_dvsn": side,
            }
        }
        try:
            resp = await self._api.send_request(req)
            logger.info(f"[kdemon] 주문 성공 rule={rule.id}, resp={resp}")
        except Exception as e:
            logger.error(f"[kdemon] 주문 실패 rule={rule.id}: {e}")

    # ---------- rule evaluation ----------
    def _in_valid_window(self, rule: Rule) -> bool:
        now = now_ymdhms()
        if rule.valid_from and now < rule.valid_from:
            return False
        if rule.valid_to and now > rule.valid_to:
            return False
        return True

    def _cooldown_ok(self, rule: Rule) -> bool:
        if not rule.last_triggered_at:
            return True
        last = datetime.strptime(rule.last_triggered_at, "%Y%m%d%H%M%S")
        return datetime.now() >= (last + timedelta(seconds=rule.cooldown_sec))

    def _should_trigger(self, rule: Rule, price: float) -> bool:
        op = rule.condition_op
        th = rule.threshold
        lp = rule.last_price

        if op == "gte":
            return price >= th
        if op == "lte":
            return price <= th
        if op == "cross_up":
            return lp is not None and lp < th and price >= th
        if op == "cross_down":
            return lp is not None and lp > th and price <= th
        logger.warning(f"[kdemon] unknown condition_op: {op}")
        return False

    # ---------- control ----------
    async def start(self):
        if self._task and not self._task.done():
            logger.info("[kdemon] already running")
            return
        self._stop_event.clear()
        await self._ensure_token()
        self._rules = self._fetch_rules()
        self._set_state("running")
        self._task = asyncio.create_task(self._run())
        logger.info("[kdemon] started")

    async def stop(self):
        if not self._task:
            logger.info("[kdemon] not running")
            self._set_state("stopped")
            return
        self._stop_event.set()
        await self._task
        self._task = None
        self._set_state("stopped")
        logger.info("[kdemon] stopped")

    async def refresh(self):
        self._refresh_event.set()
        logger.info("[kdemon] refresh requested")

    async def _run(self):
        try:
            while not self._stop_event.is_set():
                # refresh?
                if self._refresh_event.is_set():
                    self._rules = self._fetch_rules()
                    self._refresh_event.clear()
                    logger.info(f"[kdemon] rules reloaded: {len(self._rules)}")

                # evaluate rules
                for rule in list(self._rules):
                    if self._stop_event.is_set():
                        break
                    if rule.status != "active":
                        continue
                    if not self._in_valid_window(rule):
                        continue
                    if not self._cooldown_ok(rule):
                        continue

                    price = await self._get_current_price(rule.symbol)
                    if price is None:
                        continue

                    triggered = self._should_trigger(rule, price)
                    if triggered:
                        await self._place_order(rule, price)
                        self._update_rule_after_tick(rule, price, True)
                        # 바로 상태 반영
                        rule.last_price = price
                        rule.last_triggered_at = now_ymdhms()
                    else:
                        self._update_rule_after_tick(rule, price, False)
                        rule.last_price = price

                await asyncio.sleep(self.poll_interval_sec)
        except asyncio.CancelledError:
            logger.info("[kdemon] task cancelled")
        except Exception as e:
            logger.exception(f"[kdemon] fatal error: {e}")
        finally:
            self._set_state("stopped")

```
```python
# backend/routes/kdemon_routes.py
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
import sqlite3

from backend.core.config import config
from backend.domains.kdemon.kdemon import KDemon, now_ymdhms

router = APIRouter(prefix="/kdemon", tags=["kdemon"])

DB_PATH = config.SQLITE_PATH  # 프로젝트 설정에 맞게

class CommandBody(BaseModel):
    cmd: str  # 'start' | 'stop' | 'refresh'
    args: dict | None = None

def _conn():
    return sqlite3.connect(DB_PATH, check_same_thread=False)

@router.post("/command")
async def send_command(body: CommandBody):
    cmd = body.cmd.lower()
    if cmd not in {"start", "stop", "refresh"}:
        raise HTTPException(400, detail="invalid cmd")

    # (옵션) 명령을 테이블에 적재
    with _conn() as c:
        c.execute("""
            INSERT INTO kdemon_commands (cmd, args_json, created_at)
            VALUES (?, ?, ?)
        """, (cmd, (body.args and json.dumps(body.args)) or None, now_ymdhms()))
        c.commit()

    demon = KDemon.get(DB_PATH, poll_interval_sec=5, dry_run=config.KDEMON_DRY_RUN)
    if cmd == "start":
        await demon.start()
    elif cmd == "stop":
        await demon.stop()
    elif cmd == "refresh":
        await demon.refresh()

    return {"ok": True, "cmd": cmd}

@router.get("/status")
def status():
    with _conn() as c:
        row = c.execute("SELECT status, updated_at FROM kdemon_state WHERE id=1").fetchone()
        cur = c.execute("SELECT COUNT(*) FROM kdemon_rules WHERE status='active'").fetchone()
    return {
        "status": row[0] if row else "unknown",
        "updated_at": row[1] if row else None,
        "active_rules": cur[0] if cur else 0
    }

```
```python
from fastapi import FastAPI
import sqlite3
from backend.core.config import config
from backend.routes import kdemon_routes

def init_kdemon_schema(db_path: str):
    ddl = open("sql/kdemon_schema.sql", "r", encoding="utf-8").read()  # 위 스키마 저장 파일
    with sqlite3.connect(db_path, check_same_thread=False) as c:
        c.executescript(ddl)
        c.commit()

app = FastAPI()

@app.on_event("startup")
async def on_startup():
    init_kdemon_schema(config.SQLITE_PATH)

app.include_router(kdemon_routes.router)

```

## OpentimeChecker

- singleton
- public mehtod getMarket : 
  - 오늘이 휴장일인가?
  - 지금 시각이 KRX가능시간인가? 만약 그렇다면 KRX, 
  - 지금 시각이 NXT? 그렇다면 NXT
  - 아니면 None
- isHoliday
- isKrxTime
- isNxtTime
- 공공데이터의 이용
```
GODATA_URL = 'http://apis.data.go.kr/B090041/openapi/service/SpcdeInfoService/getRestDeInfo'

def get_holiday_list(year: int, month: int):
    """특정 연도와 월의 공휴일 목록을 OpenAPI에서 가져와 리스트로 반환"""
    time.sleep(1)  # OpenAPI 요청 제한 방지를 위한 대기 시간
    API_KEY = Config.GODATA_API_KEY
    params = {'serviceKey': API_KEY, 'solYear': year, 'solMonth': f"{month:02d}"}

    response = requests.get(GODATA_URL, params=params, verify=False)

    if response.status_code != 200:
        print(f"❌ OpenAPI 요청 실패: {response.status_code}")
        return []

    # XML 파싱
    root = ET.fromstring(response.text)
    holidays = [item.find("locdate").text for item in root.findall(".//item") if item.find("isHoliday").text == "Y"]

    return holidays
```
- isHoliday 로직
  1. memory에 오늘이 holiday인지 값이 있으면 true
  2. cache의 값이 오늘이 아니면 체크시작
  3. 오늘이 토,일인제 체크, 토일이면  true
  4. 오늘의 year,  month로 GODATA를 가져와서 오늘이 리스트에 있으면 true
  5. 각 단계마다. cache를 비우고 값을 채운다.
- 증시가 열리는 날이면서 오전 9:00-15:30 은 KRX
- 15:30~20:00, 08:00~08:50 NXT 리턴
